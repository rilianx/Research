# IbexMOP3

**Idea:** Usar plane-segments (caja+plano) para definir frontera no-dominada en vez de usar puntos.

## Generación de plane-segments

Básicamente consiste en (1) convexificar el problema, (2) generar un polígono factible en x y (3) proyectarlo en y.

1. Sea $R$ una región *factible convexa*, se buscan $m$ soluciones dentro $x^{(1)}, x^{(2)},...$ que *intentan* minimizar cada uno de los objetivos, i.e., $f_1 ,f_2, ...$, respectivamente. Notar que como $R$  es factible y convexa, el politopo $\mathtt{X}$ formado por los puntos también es factible.
2. Se crea caja ${\bf x} = {\it hull}(x^{(j)})$, para $j \in \{1..m\}$
3. Se obtienen funciones lineales para cada objetivo tal que para todo $x\in {\bf x}$ se cumpla que $fl_1(x) \geq f_1(x)$, $fl_2(x) \geq f_2(x)$, ... Note that for all  $x\in {\bf x}$, $f(x)$ dominates $fl(x)$
4. Sea $y^{(j)}=fl_j(x^{(j)})$, entonces, el politopo con vértices $y^{(1)}, y^{(2)},...,y^{(m)}$ está dominado por puntos $f(x)$ con $x \in \mathtt{X}$.
	* **Proof:** As $fl$ are linear functions, each point $y$ in the polytope $\mathtt{Y}$ correspond to $y=fl(x)$ for some point $x$ in the polytope $\mathtt{X}$. And, by definition, $fl(x)$ is dominated by $f(x)$.
5. El politopo se puede representar por la caja  ${\bf y} = {\it hull}(y^{(j)})$ y el plano que pasa por los puntos.

## How to use plane-segments in the search?

**Fase 1**
* Agregar plane-segments a conjunto $S$.
* Implementar método que vaya fragmentando y eliminado regiones dominadas de un plane-segment.
* **Descarte de cajas**. Agregar **olb** (oblique lower bound) como restricción auxiliar. Usar olb para descarte de cajas dominadas por $S$.

**Fase 2**
* Usar $S$ para contracción
* Calcular distancia de cajas:
	* Usar $S$ para saber si el nodo seleccionado en la búsqueda, se encuentran dominado o está a una distancia menor a $\epsilon$.
	* Usar $S$ para calcular distancia de cajas y seleccionar una de las más lejanas.

### How to contract a box using plane-segments?

La idea es hacer algo más o menos así.
![Contracción usando plane-segments](https://i.imgur.com/wsLb7iA.png)

Se puede usar un plane-segment a la vez, tipo hc4.
Contracción usando plane-segments
![contracting](https://i.imgur.com/HRKLga9.png)

**Proyecto jupyter**

![image](https://i.imgur.com/RgchjIE.png)

Politopos generan *hipersemgentos* convexos de dominancia (región convexa dominada $\mathtt{D}$

### Contracción usando hipersegmento $\mathtt{D}$

Para contractar caja **y** usando hipersegmentos $\mathtt{D}$:
1. Buscar mínimo valor $y_1^*$ tal que $(y_1^*, \underline{y_2}, \underline{y_3})$ se encuentra dominado por $\mathtt{D}$. --> debería ser superfast ya que es un problema univariado!
2. Luego, podemos mejorar: $\overline{y_1}=y_1^*$ de la caja **y**
3. Repetir para otras dimensiones
![filtering_with_D](https://i.imgur.com/9c2Gl8S.png)


### Contracción en caja: $\mathbf{y}+c_\mathbf{y}$

Se debería buscar el mínimo $y_3^*$, tal que la caja $\mathbf y(y_3)+c_\mathbf{y}$ se encuentre dominada por la región $\mathtt{D}$. La caja depende de y_3 como se aprecia en la figura:

![filtering_with_c2](https://i.imgur.com/gtqnXMe.png)

Para saber si la caja es dominada por el segmento, basta con verificar si los puntos rojos y amarillos son dominados. 

Los puntos amarillos se verifican una vez, para los puntos rojos debemos encontrar el $\min y_3^*$  para el cual se encuentran dominados. Es decir, encontrar el $\min y_3^*$, tal que puntos rojos (que dependen de y_3) pasan por sobre D.

 Si es así, podemos eliminar la región de la caja con $y_3\geq y_3^*$

Región después de filtrado:

![filtering_with_c3](https://i.imgur.com/Gky7Ehd.png)

Notar que **prisma rosado** es una región infactible que se deduce de la intersección del plano en la cara superior. No se si se le podrá dar alguna utilidad. Quizás agregar como restricción para el filtrado.-> no aportaría nada, ya que plano $c_\mathbf{y}$ se deduce a partir del filtrado y es más fuerte que prisma.

### Como buscar los mínimos puntos dominados por un hipersegmento?

**Idea** (mínimo $y_1$, con otros valores fijos)

Dominancia de hiper-segmento se puede representar por su **hull-box** + hiper-segmentos convexos (ver figura). 

![image](https://i.imgur.com/PkP3R2x.pngg)

Bastaría con calcular $y_1$ usando los hiper-segmentos y los valores fijos y quedarnos con el mayor.

En caso de tener una hiper-segmento 1D: $t=y_1$, (t,y_2(t),y_3(t)), habría que encontrar el punto intersección para los hiper-segmentos dominados (despejar $t$) y encontrar el máximo valor de $t$.

*Ejemplo:*
Hiperplanos:
$5y_1 + 4y_2 + y_3 = 0$
$y_1 + 3y_2 + 2 y_3 = 0$
$y_1 + y_2 + 4y_3 = 0$

Linea:
$t=y_1$
$y_2(t)=t+1$
$y_3(t)=t+1$

Luego se resuelve cada ecuación en función de $t$ y listo!

### Implementación

Implementada función que genera hp-box (hyperplane+box) a partir de un polígono.
![image](https://i.imgur.com/CNas1FC.png)

![image](https://i.imgur.com/7Vmchuv.png)

Faltaría implementar:

- `double min_t(i=0, c(y), hpbox)`: Función que retorna el menor valor de $t=y_i$, tal que el punto en $c(y)=0$ es dominado por hpbox.
- `contract(box, c(y), hpbox)` Función que contracta la caja usando un hpbox específico. 
**Condición necesaria para contractar dimensión $i$**: *lb de hpbox debe dominar en todas las otras dimensiones.*

````python
def contract(y, cy(ay+b), Dbox):    

    dim = len(y)
    for i in range(dim):
        # se quiere contractar y[i].ub
        # p0: intersección de (y,y2.lb,y3.lb) con cx
        p = y.lb
        p[i] = (cy(y) - a[i]*y[i].lb)/a[i]
        
        #reducción de yi_ub --> pi
		# grad (a1, 0, 0, 0,...)
        #reducción desde pi
        # grad (a1, -a2, 0, 0,...); (a1, 0, -a3, 0, 0,..)
        grad= np.zeros(dim)
        grad[i] = a[i]
        for j in range(dim):
            if i==j: continue
            grad[j]=-cy[j]
            max_t=None
            for d in len(Dbox):
                t s.t. p-grad*t=Dbox[d]
                if max_t=None or max_t<t: max_t=t
            if max_t: ub=p[i]-grad[i]*max_t
            else: ub=+inf
            if ub<y[i].ub: y[i].ub=ub
            grad[j]=0
````
![filtering_with_c4](https://i.imgur.com/WzGs3YT.png)

### TODO

- Revisar solver ibexmop3 (imprimir puntos) :ok:
![image](https://i.imgur.com/Nt1kg8D.png)

![image](https://i.imgur.com/6DDa0Wm.png)

![dominated_segments](https://i.imgur.com/DJwfEEC.png)
Cada bound de la caja tiene un punto asociado:
miny1 ->A
miny2 -> B
...
Luego, los puntos min,max,max forman polígonos con los puntos asociados correspondientes.


- PolyPlanes se agregan a lista :ok:
- Probar función `OptimizerMOP::dominance_polyp` para contractar cajas (graficar) :ok:
- Revisar contracción:
![image](https://i.imgur.com/uO7urxS.png)

- Agregar plano cy  al sistema
- Filtrar con plano cy

`./__build__/plugins/optim-mop/ibexmop plugins/optim-mop/benchs/binh4.txt --eps=0.1 --write-nds --write-seg`


---

### Generación de hiperplanos dominados 2.0

A partir de un polígono $P$ de $m \leq n$ vértices.
Eliminar vértices dominados.

Los planos deberían pasar por los puntos $y^i=(\overline{y_1},...,\underline{y_i},...,\overline{y_n})$ de la caja $\mathbf{y}$.

Seleccionar los puntos $y^i$ que **no correspondan** a los vértices de $P$.

Luego, iterar por los componentes $k$ de $y^i$ e ir seleccionando los puntos $p$ con $p_k=y^i_k$. Luego de seleccionar un punto, todos los componentes equivalentes en $y^i$ se marcan ya que no deberían ser revisados.
Generar un plano con el polígono $(p_1,p_2,y^i)$

### Observaciones

![image](https://i.imgur.com/kdg6XJO.png)

Los hiperplanos son básicamente proyecciones de las aristas. 


**Condición para contractar (Proyección debe "caer" dentro de caja)**
![image](https://i.imgur.com/5Kw5yot.png)


### TODO

- Revisar contracción usando planos
![image](https://i.imgur.com/arVs2ru.png)
Debería contractarse y,z en el ejemplo (sólo se contracta x)
- Revisar planos redundantes generados, y planos que falten..


## Construcción de hplanes

1. Mirar polígono desde punta de vector ortonormal, e identificar puntos medios para cada segmento. :ok:

**Plano:** $ax + by + cz + d= 0;~~~~$$a,b,c\geq 0$
**Vector normal:** $(a,b,c)$

![image](https://i.imgur.com/vyD7Xek.png)

2. Generar puntos dominados sumando vector epsilon-unitario para obtener puntos en 3 direcciones. Y los proyectamos en el plano. :ok:

![generating hplanes](https://i.imgur.com/YdlaAMl.png)

4. Seleccionamos punto más lejano al punto central del polígono?.


**Distancia de un punto a un hiperplano**
![image](https://i.imgur.com/lt2W6Ms.png)

## Construcción de planos

![image](https://i.imgur.com/Rm3WbHm.png)
O el HP que domina el punto centro del polígono.

Los planos se construyen con [producto cruz generalizado](https://math.stackexchange.com/questions/2723294/how-to-determine-the-equation-of-the-hyperplane-that-contains-several-points)
![image](https://i.imgur.com/PI462UE.png)


**TODO**

- Cómo implementar producto cruz generalizado (determinante)?
- Selección de puntos cuando vector del plano no es positivo.
	- ¿Cómo se generan planos en este caso? Aristas con más planos válidos
- Revisando para 4dim: [jupyter](http://localhost:8888/lab/tree/Documents/research_on_github/%2Blocal_projects/ibexmop3/proj_angle.ipynb)

Para cada arista, los planos válidos corresponden a los coeficientes positivos del vector. En la figura:

![generating hplanes](https://i.imgur.com/YdlaAMl.png)

vector que aumenta en x e y: Planos válidos en direcciones X, Y
(++-) XY
(-++) YZ

**Y en 4D?**
Tengo un politopo a partir de 4 puntos.
Con cada combinación de 3 puntos + un punto extra puedo generar un politopo dominado.
No me queda claro qué politopos puedo generar a partir de 3 puntos. Ni a partir de 2.

(3,4,1,2)
(0,0,0,0)
==>
(0,1,1,0)


## Retomando idea general

1. Identificar politopos dominados definidos por sus vértices.
2. Crear hiperplanos convexos que definan el politopo (parte difícil).
3. Almacenar lista P de politopos con sus hiperplanos
4. Usar P para reducir cajas antes de contractar (peeler-method).

**Pregunta:** *¿Es posible usar directamente el politopo obtenido de la inner-linearization?*

Este politopo está definido por un conjunto de restricciones lineales en el espacio X. Además, el politopo es válido dentro de una caja **x**.

¿ Cómo obtener la región dominada a partir de las restricciones ?
$y$ es dominado si existe un $y'$ con $y_1' \leq y_1$, $y_2'\leq y_2$.

Para contractar $y_1$ de caja $\bf{y}$ necesitamos:
Encontrar un mínimo valor $y_1^*$,​ tal que exista algún $x \in \bf{x}$, para el cual $f(x) \leq y_1^*$ y $f_2(x) \leq \underline{y_2}$.
Esto se hace resolviendo un programa lineal no (aka simplex)?
También se podría aplicar dual-contractor par evitar llamar a simplex.

### ¿Y cómo agregamos plano $c_y$?

Sabemos que $c_y(y)>w$.
Si queremos reducir $y_i$. Usando la restricción deberíamos ser capaces de obtener los puntos que intersectan con la hipercaja en función del valor de $y_i$. Es decir:
$p^j = p^j(y_i)$. 

![filtering_with_c4](https://i.imgur.com/WzGs3YT.png)

Luego, agregamos las restricciones de que cada uno de estos puntos $p^j$ es **dominado** y buscamos el mínimo $y_i$ que satisface las restricciones.

### Puesta a punto IbexMop3 (XD)

- Comparar resultados en 2D con [paper](https://drive.google.com/file/d/1pzvXylY6OrmawsCZ8HLl_m8dtlLpZ31n/view)
- Puntos en estructura eficiente (kd-tree?)
	- Necesito saber si un punto está dominado -> búsqueda de punto dentro de caja
	- Necesito encontrar todos los puntos dominados por punto -> búsqueda de puntos dentro de caja
	- Necesito encontrar cutting points (para peeler). Son puntos que dominan a caja en todas las dimensiones menos en una. Además, en la que no dominan son mínimos.
![image](https://i.imgur.com/EWRp0Mt.png)
- Implementar plano inferior y cálculo de distancia 
- Agregar eps-constraint

### Politopos Factibles
- Crear estructura para almacenar politopos factibles.
- Crear métodos para filtrar usando politopos factibles.
- Implementar cy-contract para más dimensiones.
- ¿Cómo seleccionar qué politopos usar para filtrar caja actual?

**Problems:**
![image](https://i.imgur.com/CkR1IGT.png)

**Comparison (paper2)**
![image](https://i.imgur.com/1zSIG9q.png)

**Paper1**
![image](https://i.imgur.com/gU8ZvJx.png)

![image](https://i.imgur.com/ibHxSqT.png)

**Comando**

``
./__build__/plugins/optim-mop/ibexmop plugins/optim-mop/benchs/binh4.txt --eps=0.1
``


[Preliminary results](https://docs.google.com/spreadsheets/d/1P0XspMb-K3aLJvL7cbViomYAFhqN11gC_5T7Y7jj7R8/edit#gid=0)

Usar árbol para cálculo de distancia
![image](https://i.imgur.com/M144elp.png)

## TODO

1. Agregar plano inferior para contracción $c_y(y) > w$ :ok:
2. Verificar contracción usando plano inferior
3. Cálculo de distancia usando plano inferior
4. Agregar eps-constraint. Reducir $y$ al hacer peeler.
5. Almacenamiento de politopos $P_x$.
	- Sistema lineal: $g(x)\leq 0$ + caja $\mathbf{x}$.
6. Contracción usando politopos $P_x$:
	- $\min y_i$, s.t., $f_i(x)\leq y_i; f_j(x)\leq y_j(y_i)$
	- $y_j(y_i)$ se deduce de $c_y(y) = w$, con $y_k=\underline{y_k}$ para $k \neq i, j$

<!--stackedit_data:
eyJoaXN0b3J5IjpbNzAwMDcwODksMTA5NjMzOTUxNywtMTMwND
MwNzkwNCwtOTg4MTM2NDMwLC0zMDE2Mzk3MTksLTEyNjIwOTEx
MDIsMTI3MTkzMTUzNSwtMTMwNDI3OTM2OSwtMjUyOTQyMzIxLC
0xMzUxNzQxMDQ3LDEzMzMyNTc2MTEsLTE4OTY3NTM3MjQsLTQx
MTU1ODYwNSwtMTUzMzE0NzMzNCwtMTgyNDAzODAxMCwxMjUzND
I4MzUxLDIxMjE1MTI5MDIsODYxOTY1MDg5LDE0MjQ1MTE0NDEs
MTQyMzI5NTY3NF19
-->