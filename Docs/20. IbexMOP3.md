# IbexMOP3

**Idea:** Usar plane-segments (caja+plano) para definir frontera no-dominada en vez de usar puntos.

## Generación de plane-segments

Básicamente consiste en (1) convexificar el problema, (2) generar un polígono factible en x y (3) proyectarlo en y.

1. Sea $R$ una región *factible convexa*, se buscan $m$ soluciones dentro $x^{(1)}, x^{(2)},...$ que *intentan* minimizar cada uno de los objetivos, i.e., $f_1 ,f_2, ...$, respectivamente. Notar que como $R$  es factible y convexa, el politopo $\mathtt{X}$ formado por los puntos también es factible.
2. Se crea caja ${\bf x} = {\it hull}(x^{(j)})$, para $j \in \{1..m\}$
3. Se obtienen funciones lineales para cada objetivo tal que para todo $x\in {\bf x}$ se cumpla que $fl_1(x) \geq f_1(x)$, $fl_2(x) \geq f_2(x)$, ... Note that for all  $x\in {\bf x}$, $f(x)$ dominates $fl(x)$
4. Sea $y^{(j)}=fl_j(x^{(j)})$, entonces, el politopo con vértices $y^{(1)}, y^{(2)},...,y^{(m)}$ está dominado por puntos $f(x)$ con $x \in \mathtt{X}$.
	* **Proof:** As $fl$ are linear functions, each point $y$ in the polytope $\mathtt{Y}$ correspond to $y=fl(x)$ for some point $x$ in the polytope $\mathtt{X}$. And, by definition, $fl(x)$ is dominated by $f(x)$.
5. El politopo se puede representar por la caja  ${\bf y} = {\it hull}(y^{(j)})$ y el plano que pasa por los puntos.

## How to use plane-segments in the search?

**Fase 1**
* Agregar plane-segments a conjunto $S$.
* Implementar método que vaya fragmentando y eliminado regiones dominadas de un plane-segment.
* **Descarte de cajas**. Agregar **olb** (oblique lower bound) como restricción auxiliar. Usar olb para descarte de cajas dominadas por $S$.

**Fase 2**
* Usar $S$ para contracción
* Calcular distancia de cajas:
	* Usar $S$ para saber si el nodo seleccionado en la búsqueda, se encuentran dominado o está a una distancia menor a $\epsilon$.
	* Usar $S$ para calcular distancia de cajas y seleccionar una de las más lejanas.

### How to contract a box using plane-segments?

La idea es hacer algo más o menos así.
![Contracción usando plane-segments](https://i.imgur.com/wsLb7iA.png)

Se puede usar un plane-segment a la vez, tipo hc4.
Contracción usando plane-segments
![contracting](https://i.imgur.com/HRKLga9.png)

**Proyecto jupyter**

![image](https://i.imgur.com/RgchjIE.png)

Politopos generan *hipersemgentos* convexos de dominancia (región convexa dominada $\mathtt{D}$

### Contracción usando hipersegmento $\mathtt{D}$

Para contractar caja **y** usando hipersegmentos $\mathtt{D}$:
1. Buscar mínimo valor $y_1^*$ tal que $(y_1^*, \underline{y_2}, \underline{y_3})$ se encuentra dominado por $\mathtt{D}$. --> debería ser superfast ya que es un problema univariado!
2. Luego, podemos mejorar: $\overline{y_1}=y_1^*$ de la caja **y**
3. Repetir para otras dimensiones
![filtering_with_D](https://i.imgur.com/9c2Gl8S.png)


### Contracción en caja: $\mathbf{y}+c_\mathbf{y}$

Se debería buscar el mínimo $y_3^*$, tal que la caja $\mathbf y(y_3)+c_\mathbf{y}$ se encuentre dominada por la región $\mathtt{D}$. La caja depende de y_3 como se aprecia en la figura:

![filtering_with_c2](https://i.imgur.com/gtqnXMe.png)

Para saber si la caja es dominada por el segmento, basta con verificar si los puntos rojos y amarillos son dominados. 

Los puntos amarillos se verifican una vez, para los puntos rojos debemos encontrar el $\min y_3^*$  para el cual se encuentran dominados. Es decir, encontrar el $\min y_3^*$, tal que puntos rojos (que dependen de y_3) pasan por sobre D.

 Si es así, podemos eliminar la región de la caja con $y_3\geq y_3^*$

Región después de filtrado:

![filtering_with_c3](https://i.imgur.com/Gky7Ehd.png)

Notar que **prisma rosado** es una región infactible que se deduce de la intersección del plano en la cara superior. No se si se le podrá dar alguna utilidad. Quizás agregar como restricción para el filtrado.-> no aportaría nada, ya que plano $c_\mathbf{y}$ se deduce a partir del filtrado y es más fuerte que prisma.

### Como buscar los mínimos puntos dominados por un hipersegmento?

**Idea** (mínimo $y_1$, con otros valores fijos)

Dominancia de hiper-segmento se puede representar por su **hull-box** + hiper-segmentos convexos (ver figura). 

![image](https://i.imgur.com/PkP3R2x.pngg)

Bastaría con calcular $y_1$ usando los hiper-segmentos y los valores fijos y quedarnos con el mayor.

En caso de tener una hiper-segmento 1D: $t=y_1$, (t,y_2(t),y_3(t)), habría que encontrar el punto intersección para los hiper-segmentos dominados (despejar $t$) y encontrar el máximo valor de $t$.

*Ejemplo:*
Hiperplanos:
$5y_1 + 4y_2 + y_3 = 0$
$y_1 + 3y_2 + 2 y_3 = 0$
$y_1 + y_2 + 4y_3 = 0$

Linea:
$t=y_1$
$y_2(t)=t+1$
$y_3(t)=t+1$

Luego se resuelve cada ecuación en función de $t$ y listo!

### Implementación

Implementada función que genera hp-box (hyperplane+box) a partir de un polígono.
![image](https://i.imgur.com/CNas1FC.png)

![image](https://i.imgur.com/7Vmchuv.png)

Faltaría implementar:

- `double min_t(i=0, c(y), hpbox)`: Función que retorna el menor valor de $t=y_i$, tal que el punto en $c(y)=0$ es dominado por hpbox.
- `contract(box, c(y), hpbox)` Función que contracta la caja usando un hpbox específico. 
**Condición necesaria para contractar dimensión $i$**: *lb de hpbox debe dominar en todas las otras dimensiones.*

````python
def contract(y, cy(ay+b), Dbox):    

    dim = len(y)
    for i in range(dim):
        # se quiere contractar y[i].ub
        # p0: intersección de (y,y2.lb,y3.lb) con cx
        p = y.lb
        p[i] = (cy(y) - a[i]*y[i].lb)/a[i]
        
        #reducción de yi_ub --> pi
		# grad (a1, 0, 0, 0,...)
        #reducción desde pi
        # grad (a1, -a2, 0, 0,...); (a1, 0, -a3, 0, 0,..)
        grad= np.zeros(dim)
        grad[i] = a[i]
        for j in range(dim):
            if i==j: continue
            grad[j]=-cy[j]
            max_t=None
            for d in len(Dbox):
                t s.t. p-grad*t=Dbox[d]
                if max_t=None or max_t<t: max_t=t
            if max_t: ub=p[i]-grad[i]*max_t
            else: ub=+inf
            if ub<y[i].ub: y[i].ub=ub
            grad[j]=0
````
![filtering_with_c4](https://i.imgur.com/WzGs3YT.png)

### TODO

- Revisar solver ibexmop3 (imprimir puntos) :ok:
![image](https://i.imgur.com/Nt1kg8D.png)

![image](https://i.imgur.com/6DDa0Wm.png)

![dominated_segments](https://i.imgur.com/DJwfEEC.png)
Cada bound de la caja tiene un punto asociado:
miny1 ->A
miny2 -> B
...
Luego, los puntos min,max,max forman polígonos con los puntos asociados correspondientes.


- PolyPlanes se agregan a lista :ok:
- Probar función `OptimizerMOP::dominance_polyp` para contractar cajas (graficar) :ok:
- Revisar contracción:
![image](https://i.imgur.com/uO7urxS.png)

- Agregar plano cy  al sistema
- Filtrar con plano cy

`./__build__/plugins/optim-mop/ibexmop plugins/optim-mop/benchs/binh4.txt --eps=0.1 --write-nds --write-seg`


---

### Generación de hiperplanos dominados 2.0

A partir de un polígono $P$ de $m \leq n$ vértices.
Eliminar vértices dominados.

Los planos deberían pasar por los puntos $y^i=(\overline{y_1},...,\underline{y_i},...,\overline{y_n})$ de la caja $\mathbf{y}$.

Seleccionar los puntos $y^i$ que **no correspondan** a los vértices de $P$.

Luego, iterar por los componentes $k$ de $y^i$ e ir seleccionando los puntos $p$ con $p_k=y^i_k$. Luego de seleccionar un punto, todos los componentes equivalentes en $y^i$ se marcan ya que no deberían ser revisados.
Generar un plano con el polígono $(p_1,p_2,y^i)$

### Observaciones

![image](https://i.imgur.com/kdg6XJO.png)

Los hiperplanos son básicamente proyecciones de las aristas. 


**Condición para contractar (Proyección debe "caer" dentro de caja)**
![image](https://i.imgur.com/5Kw5yot.png)


### TODO

- Revisar contracción usando planos
![image](https://i.imgur.com/arVs2ru.png)
Debería contractarse y,z en el ejemplo (sólo se contracta x)
- Revisar planos redundantes generados, y planos que falten..


## Construcción de hplanes

1. Mirar polígono desde punta de vector ortonormal, e identificar puntos medios para cada segmento. :ok:

**Plano:** $ax + by + cz + d= 0;~~~~$$a,b,c\geq 0$
**Vector normal:** $(a,b,c)$

![image](https://i.imgur.com/vyD7Xek.png)

2. Generar puntos dominados sumando vector epsilon-unitario para obtener puntos en 3 direcciones. Y los proyectamos en el plano. :ok:

![generating hplanes](https://i.imgur.com/YdlaAMl.png)

4. Seleccionamos punto más lejano al punto central del polígono?.


**Distancia de un punto a un hiperplano**
![image](https://i.imgur.com/lt2W6Ms.png)

## Construcción de planos

![image](https://i.imgur.com/Rm3WbHm.png)
O el HP que domina el punto centro del polígono.

Los planos se construyen con [producto cruz generalizado](https://math.stackexchange.com/questions/2723294/how-to-determine-the-equation-of-the-hyperplane-that-contains-several-points)
![image](https://i.imgur.com/PI462UE.png)


**TODO**

- Cómo implementar producto cruz generalizado (determinante)?
- Selección de puntos cuando vector del plano no es positivo.
	- ¿Cómo se generan planos en este caso? Aristas con más planos válidos
- Revisando para 4dim: [jupyter](http://localhost:8888/lab/tree/Documents/research_on_github/%2Blocal_projects/ibexmop3/proj_angle.ipynb)

Para cada arista, los planos válidos corresponden a los coeficientes positivos del vector. En la figura:

![generating hplanes](https://i.imgur.com/YdlaAMl.png)

vector que aumenta en x e y: Planos válidos en direcciones X, Y
(++-) XY
(-++) YZ

**Y en 4D?**
Tengo un politopo a partir de 4 puntos.
Con cada combinación de 3 puntos + un punto extra puedo generar un politopo dominado.
No me queda claro qué politopos puedo generar.



<!--stackedit_data:
eyJoaXN0b3J5IjpbMjE1OTQ0NjYsNzg4OTIxMDU0LDc0OTcwND
IwNCwtMTczNTE0MDI1NywtNjgwMzYwMDkwLDgzNTg1MTM4MSwt
MTQzNTk0NjE0Miw2NTQ2NTUxMywxMzIyMTI1OTM4LC0yNzYwNj
kxMzEsMTAzNzE3MTg0LDEwODUxODgxNjgsLTgyNTI1MTIyOCwx
NzgyOTg5OTAsLTEwOTM2MzEwODAsLTIwMDc2NzY5NzIsODM5OT
I3MzgwLC0zMjU2OTU5NDAsNjU2MjM2NDM3LC0xODE5MTEyNl19

-->